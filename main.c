#include "main.h"

#include <stdio.h>
#include <stdlib.h>

#include "gba.h"

#include "images/beachPic.h"
#include "images/oceanBackground.h"
#include "images/puppy.h"

/* TODO: */
// Include any header files for title screen or exit
// screen images generated by nin10kit. Example for the provided garbage
// image:
// #include "images/garbage.h"

/* TODO: */
// Add any additional states you need for your app. You are not requried to use
// these specific provided states.
enum gba_state {
  START,
  PLAY,
  WIN,
  LOSE,
};

int main(void) {
  /* TODO: */
  // Manipulate REG_DISPCNT here to set Mode 3. //
  REG_DISPCNT = MODE3 | BG2_ENABLE;
  // Save current and previous state of button input.
  u32 previousButtons = BUTTONS;
  u32 currentButtons = BUTTONS;
  struct soccerBall ball = {HEIGHT/2, WIDTH/2, 1, 1, BLACK};
  struct goalKeeper playerGK = {20, 20, 8, 28, RED, 0, 0};
  struct goalKeeper autoGK = {HEIGHT-48, WIDTH-28,8,28,GREEN, 0, -1};
  // Load initial application state
  enum gba_state state = START;

  int pState = 0;
  while (1) {
    currentButtons = BUTTONS; // Load the current state of the buttons

    /* TODO: */
    // Manipulate the state machine below as needed //
    // NOTE: Call waitForVBlank() before you draw

    waitForVBlank();
    switch (state) {
      case START:
        drawStartScreen();
        state = PLAY;
      
        break;
      case PLAY:
      ;
        char str1[12];
        char str2[12];
        sprintf(str1,"P1 %d",playerGK.score);
        sprintf(str2,"P2 %d",autoGK.score);
        //sprintf()
        drawRectDMA(5, WIDTH/3-20,70,20, BLUE);
        drawRectDMA(5, 2*WIDTH/3-20,70,20,BLUE);
        if(paddleScoreCollision(&ball,&playerGK, &autoGK) != 4){
          pState = stateChange(currentButtons, previousButtons, playerGK, autoGK);
        } 
        else {
          pState = 4;
        }
        drawCenteredString(10,WIDTH/3,1,1, str1, WHITE);
        drawCenteredString(10,2*WIDTH/3,1,1,str2,WHITE);
        switch(pState){
          case 0:
            break;
          case 1:
            drawRectDMA(playerGK.row+playerGK.height, playerGK.col, playerGK.width,1, BLUE);
            playerGK.row -= 1;
            break;
          case 2:
            drawRectDMA(playerGK.row, playerGK.col, playerGK.width, 1, BLUE);
            playerGK.row += 1;
            break;
          case 3:
            pState = 0;
            state = START;
            ball.row=HEIGHT/2;
            ball.col=WIDTH/2;
            playerGK.row = 20; 
            autoGK.row = HEIGHT-48;
            playerGK.score = 0;
            autoGK.score = 0;
            break;
          case 4:
            pState = 0;
            drawRectDMA(ball.row, ball.col, 5, 5, BLUE);
            ball.row=HEIGHT/2;
            ball.col=WIDTH/2;
            ball.rowDirect = ball.rowDirect*-1;
            ball.colDirect = ball.colDirect*-1;
            break;
          case 5:
            state = WIN;
            break;
          case 6:
            state = LOSE;
            break;
        }
        drawRectDMA(ball.row, ball.col, 5, 5, BLUE);   
        int updateDirect = vCollision(ball);
        if(updateDirect != 0){
          ball.rowDirect = updateDirect;
        }  
        ball.row += ball.rowDirect;
        ball.col += ball.colDirect;
        autoDirect(&autoGK);
        if(autoGK.direct == 1){
          drawRectDMA(autoGK.row, autoGK.col, autoGK.width, 1, BLUE);
        }
        else{
          drawRectDMA(autoGK.row+autoGK.height, autoGK.col, autoGK.width,1, BLUE);
        }
        autoGK.row += autoGK.direct;
        drawRectDMA(playerGK.row,playerGK.col,playerGK.width,playerGK.height,playerGK.color);
        drawRectDMA(autoGK.row,autoGK.col,autoGK.width,autoGK.height,autoGK.color);
        drawRectDMA(ball.row, ball.col, 5, 5, ball.color);
      
        break;
      case WIN:
        if(pState == 5){
          drawFullScreenImageDMA(oceanBackground);
          drawCenteredString(HEIGHT/2,WIDTH/2-5,3,3,"YOU WIN!", BLACK);
          pState = 0;
        }
        else{
          if(KEY_JUST_PRESSED(BUTTON_SELECT,currentButtons,previousButtons)){
            state = START;
            ball.row=HEIGHT/2;
            ball.col=WIDTH/2;
            playerGK.row = 20; 
            autoGK.row = HEIGHT-48;
            playerGK.score = 0;
            autoGK.score = 0;
          }
        }
      
        break;
      case LOSE:
        if(pState == 6){
          fillScreenDMA(BLACK);
          drawImageDMA(HEIGHT/3-40,WIDTH/3-20,120,90,puppy);
          drawCenteredString(HEIGHT-30,WIDTH/2,3,3,"YOU LOSE", WHITE);
          pState = 0;
        }
        else{
          if(KEY_JUST_PRESSED(BUTTON_SELECT,currentButtons,previousButtons)){
            state = START;
            ball.row=HEIGHT/2;
            ball.col=WIDTH/2;
            playerGK.row = 20; 
            autoGK.row = HEIGHT-48;
            playerGK.score = 0;
            autoGK.score = 0;
          }
        }
      
        break;
    }

    previousButtons = currentButtons; // Store the current state of the buttons
  }

  UNUSED(previousButtons); // You can remove this once previousButtons is used

  return 0;
}

void drawStartScreen(void){
  drawFullScreenImageDMA(beachPic);
  drawCenteredString(80,WIDTH/2.4,30,30,"PRESS START...", BLACK);
}

void autoDirect(struct goalKeeper *autoGK){
  if(autoGK->row == 0){
    autoGK->direct = 1;
  }
  else if((autoGK-> row + autoGK->height) == 160){
    autoGK->direct = -1;
  } 
}

int stateChange(u32 currentButtons, u32 previousButtons, struct goalKeeper playerGK, struct goalKeeper autoGK){
  if(playerGK.score == 5){
    return 5;
  }
  else if(autoGK.score == 5){
    return 6;
  }
  else{
    if(playerGK.row + playerGK.height< 160){
      if(playerGK.row > 0){
        if(KEY_JUST_PRESSED(BUTTON_UP, currentButtons, previousButtons)){
          return 1;
        }
        else if(KEY_JUST_PRESSED(BUTTON_DOWN, currentButtons, previousButtons)){
          return 2;
        }
      }
      else if(KEY_JUST_PRESSED(BUTTON_DOWN, currentButtons, previousButtons)){
          return 2;
      }
    } else if(KEY_JUST_PRESSED(BUTTON_UP, currentButtons, previousButtons)){
        return 1;
    }
    if(KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)){
      return 3;
    }
  }
  return 0;
}

int vCollision(struct soccerBall ball){
  if(ball.row+4 == 160){
    return -1;
  } 
  else if(ball.row == 0){
    return 1;
  }
  else{
    return 0;
  }
}

int paddleScoreCollision(struct soccerBall *ball, struct goalKeeper *playerGK, struct goalKeeper *autoGK) {
  int autologic = (ball->row <= ((autoGK->row+autoGK->height)-2)) && (ball->row > (autoGK->row)-4);
  int playerLogic = (ball->row <= ((playerGK->row+playerGK->height)-2)) && (ball->row > (playerGK->row)-4);
  if(ball->col == 236){
    playerGK->score += 1;
    return 4;
  }
  else if(ball->col == 0){
    autoGK->score += 1;
    return 4;
  } 
  else if(((ball->col)==((autoGK->col)-4)) && (autologic)){
      ball->colDirect = -1;
  }
  else if(((ball->col)==((playerGK->col)+8)) && (playerLogic)){
      ball->colDirect = 1;
  }
  return 0;
}
